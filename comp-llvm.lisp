(in-package "NB")
(defun mappend (fn the-list)
  (if (null the-list)
      nil
      (append (funcall fn (first the-list))
              (mappend fn (rest the-list)))))
(defun length=1 (x)
  (and (consp x) (null (cdr x))))
; (comp-show '(if (= x y) (f (g x)) (h x y (h 1 2))))
;; each instruction should be expanded into a few appropriate LLVM instructions 
(defun comp (x env)
  (cond 
   ((symbolp x) (gen-var x env))
   ((atom x) (gen 'CONST x))
   ((case (first x)
      (QUOTE  (gen 'CONST (second x)))
      (BEGIN  (comp-begin (rest x) env))
      (SET!   (seq (comp (third x) env) (gen-set (second x) env)))
      (IF     (comp-if (second x) (third x) (fourth x) env))
      (LAMBDA (gen 'FN (comp-lambda (second x) (rest (rest x)) env)))
      ;; Procedure application
      (t      (seq (mappend #'(lambda (y) (comp y env)) (rest x))
                   (comp (first x) env)
                   (gen 'CALL (length (rest x)))))))))
(defun comp-begin (exps env)
  (cond ((null exps) (gen 'CONST nil))
        ((length=1 exps) (comp (first exps) env))
        (t (seq (comp (first exps) env)
                (gen 'POP)
                (comp-begin (rest exps) env)))))
(defun comp-if (pred then else env)
  (let ((L1 (gen-label))
        (L2 (gen-label)))
    (seq (comp pred env) (gen 'FJUMP L1)
         (comp then env) (gen 'JUMP L2)
         (list L1) (comp else env)
         (list L2))))
(defstruct (fn (:print-function print-fn))
  code (env nil) (name nil) (args nil))
(defun comp-lambda (args body env)
  (assert (and (listp args) (every #'symbolp args)) ()
          "Lambda arglist must be a list of symbol, not ~a" args)
  (make-fn
    :env env :args args
    :code (seq (gen 'ARGS (length args))
               (comp-begin body (cons args env))
               (gen 'RETURN))))
(defvar *label-num* 0)
(defun compiler (x)
  (setf *label-num* 0)
  (comp-lambda '() (list x) nil))
(defun comp-show (x)
  (show-fn (compiler x))
  (values))
(defun gen (opcode &rest args)
  (list (cons opcode args)))
(defun seq (&rest code)
  (apply #'append code))
(defun gen-label (&optional (label 'L))
  (intern (format nil "~a~d" label (incf *label-num*))))
(defun gen-var (var env)
  (let ((p (in-env-p var env)))
    (if p 
        (gen 'LVAR (first p) (second p) ";" var)
        (gen 'GVAR var))))
(defun gen-set (var env)
  (let ((p (in-env-p var env)))
    (if p
        (gen 'LSET (first p) (second p) ";" var)
        (gen 'GSET var))))
(defun print-fn (fn &optional (stream *standard-output*) depth)
  (declare (ignore depth))
  (format stream "{~a}" (or (fn-name fn) '??)))
(defun show-fn (fn &optional (stream *standard-output*) (depth 0))
  (if (not (fn-p fn))
      (format stream "~8a" fn)
      (progn
        (fresh-line)
        (incf depth 8)
        (dolist (instr (fn-code fn))
          (if (label-p instr)
              (format stream "~a:" instr)
              (progn
                (format stream "~VT" depth)
                (dolist (arg instr)
                  (show-fn arg stream depth))
                (fresh-line)))))))
(defun label-p (x) (atom x))
(defun in-env-p (symbol env)
  (let ((frame (find symbol env :test #'find)))
    (if frame (list (position frame env) (position symbol frame)))))
           

